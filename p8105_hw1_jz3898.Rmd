---
title: "p8105_hw1_JZ3898"
author: "Jiaqi Zhu (jz3898)"
date: "`r Sys.Date()`"
output: github_document
---
# Problem 1

```{r setup, message=FALSE}

library(moderndive)
library(ggplot2)

data("early_january_weather")
```
The `early_january_weather` dataset contains 
**`r nrow(early_january_weather)`** rows and 
**`r ncol(early_january_weather)`** columns.  
The variables included in the dataset are:

`r paste(names(early_january_weather), collapse = ", ")`.

Key variables include:
- `temp`: air temperature in Fahrenheit (range: `r range(early_january_weather$temp, na.rm = TRUE)[1]` to `r range(early_january_weather$temp, na.rm = TRUE)[2]`)
- `humid`: relative humidity as a percentage (range: `r range(early_january_weather$humid, na.rm = TRUE)[1]` to `r range(early_january_weather$humid, na.rm = TRUE)[2]`)
- `time_hour`: timestamps (first: `r min(early_january_weather$time_hour)`, last: `r max(early_january_weather$time_hour)`)

The mean temperature is 
**`r round(mean(early_january_weather$temp, na.rm = TRUE), 1)`** °F.


---

## Scatterplot of temperature vs time

```{r scatterplot, fig.width=7, fig.height=4}
ggplot(early_january_weather, aes(x = time_hour, y = temp, color = humid)) +
  geom_point(alpha = 0.6) +
  labs(
    title = "Temperature vs Time (colored by Humidity)",
    x = "Time",
    y = "Temperature (°F)"
  )
```

```{r save-plot, eval=TRUE, echo=TRUE}

ggsave("scatterplot_temp_vs_time.png", width = 7, height = 4)
```

From the scatterplot, we can see that temperature gradually increases over time, ranging roughly from the low 30s °F to the mid-50s °F. The points are colored by humidity, with lighter shades indicating higher humidity. Periods of higher humidity tend to coincide with higher temperatures, especially toward the later dates, while lower humidity values are more common when temperatures are cooler.

# Problem 2

```{r create-data, message=FALSE}
library(tidyverse)

set.seed(1234)  # for reproducibility

# Create components
num_vec = rnorm(10)
logical_vec = num_vec > 0
char_vec = letters[1:10]
factor_vec = factor(c("low", "med", "high", "low", "high", "med", "low", "med", "high", "low"))

# Combine into data frame
df = data.frame(
  num = num_vec,
  logical = logical_vec,
  character = char_vec,
  factor = factor_vec
)
df
```

We created a data frame with 10 rows and 4 columns:

- `num`: numeric values sampled from a standard normal distribution
- `logical`: TRUE if num > 0, FALSE otherwise  
- `character`: the first 10 lowercase letters
- `factor`: a categorical variable with three levels: "low", "med", and "high"

```{r}
mean(pull(df, num))
mean(pull(df, logical))
# The following will not work:
# mean(pull(df, character)) 
# mean(pull(df, factor))    
```

The numeric and logical variables can be averaged. For logical, R treats TRUE as 1 and FALSE as 0, so the mean reflects the proportion of values greater than 0.

However, character and factor variables cannot be averaged directly, as they are not numeric types.

We now try coercing each variable using as.numeric():
```{r}
as.numeric(df$logical)
as.numeric(df$character)
as.numeric(df$factor)
```

Coercing the logical variable gives 0s and 1s, which is why we could calculate the mean.

Coercing the character variable produces NAs and a warning, because letters can't be converted to numbers.

Coercing the factor variable gives the underlying integer codes of the factor levels — for example, "low" = 1, "med" = 2, "high" = 3 — which can be averaged, but this reflects level order, not actual meaning.

This exercise shows that while some coercions are possible and even useful (e.g., logical to numeric), others (like character to numeric) are inappropriate and produce missing values.

